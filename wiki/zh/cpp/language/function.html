<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>函数声明</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/function","wgTitle":"cpp/language/function","wgCurRevisionId":99466,"wgArticleId":2717,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"cpp/language/function","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_function skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">函数声明</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><p><br>
</p>
<div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"><a href="../compiler_support.html" title="cpp/compiler support">编译器支持</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../freestanding.html" title="cpp/freestanding">自立实现与有宿主实现</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../language.html" title="cpp/language">语言</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../standard_library.html" title="cpp/standard library">标准库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../header.html" title="cpp/header">标准库标头</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../named_req.html" title="cpp/named req">具名要求</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../feature_test.html" title="cpp/feature test">功能特性测试宏</a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../utility.html#.E8.AF.AD.E8.A8.80.E6.94.AF.E6.8C.81" title="cpp/utility">语言支持库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../concepts.html" title="cpp/concepts">概念库</a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../error.html" title="cpp/error">诊断库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../memory.html" title="cpp/memory">内存管理库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../meta.html" title="cpp/meta">元编程库</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../utility.html" title="cpp/utility">通用工具库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../container.html" title="cpp/container">容器库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../iterator.html" title="cpp/iterator">迭代器库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../ranges.html" title="cpp/ranges">范围库</a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../algorithm.html" title="cpp/algorithm">算法库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../string.html" title="cpp/string">字符串库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../text.html" title="cpp/text">文本处理库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../numeric.html" title="cpp/numeric">数值库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../chrono.html" title="cpp/chrono">日期和时间库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../io.html" title="cpp/io">输入/输出库</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../filesystem.html" title="cpp/filesystem">文件系统库</a> <span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../thread.html" title="cpp/thread">并发支持库</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../execution.html" title="cpp/execution">执行控制库</a> <span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../experimental.html" title="cpp/experimental">技术规范</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../symbol_index.html" title="cpp/symbol index">符号索引</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../links/libs.html" title="cpp/links/libs">外部库</a></td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../language.html" title="cpp/language">C++ 语言</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5">一般主题</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../preprocessor.html" title="cpp/preprocessor">预处理器</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../comment.html" title="cpp/comment">注释</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../keyword.html" title="cpp/keyword">关键词</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="escape.html" title="cpp/language/escape">转义序列</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="statements.html" title="cpp/language/statements">流程控制</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">条件执行语句</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="if.html" title="cpp/language/if"><tt>if</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="switch.html" title="cpp/language/switch"><tt>switch</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">重复语句（循环）</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="for.html" title="cpp/language/for"><tt>for</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="range-for.html" title="cpp/language/range-for">范围 <span class="mw-geshi cpp source-cpp"><span class="kw1">for</span></span></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="while.html" title="cpp/language/while"><tt>while</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="do.html" title="cpp/language/do"><code>do-while</code></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">跳转语句</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="continue.html" title="cpp/language/continue"><tt>continue</tt></a> - <a href="break.html" title="cpp/language/break"><tt>break</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="goto.html" title="cpp/language/goto"><tt>goto</tt></a> - <a href="return.html" title="cpp/language/return"><tt>return</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="functions.html" title="cpp/language/functions">函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><strong class="selflink">函数声明</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="lambda.html" title="cpp/language/lambda">lambda 函数表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="inline.html" title="cpp/language/inline"><span class="mw-geshi cpp source-cpp"><span class="kw1">inline</span></span> 说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="except_spec.html" title="cpp/language/except spec">动态异常说明</a> <span class="t-mark" style="white-space: nowrap;">(<span title="C++11 中弃用">C++17 前*</span>)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="noexcept_spec.html" title="cpp/language/noexcept spec"><span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> 说明符</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">异常</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="throw.html" title="cpp/language/throw"><span class="mw-geshi cpp source-cpp"><span class="kw1">throw</span></span> 表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="try.html" title="cpp/language/try"><span class="mw-geshi cpp source-cpp"><span class="kw1">try</span></span> 块</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
<tr class="t-nv"><td colspan="5"><a href="catch.html" title="cpp/language/catch"><code>catch</code> 处理块</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">命名空间</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace.html" title="cpp/language/namespace">命名空间声明</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace_alias.html" title="cpp/language/namespace alias">命名空间别名</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">类型</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="types.html" title="cpp/language/types">基础类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="enum.html" title="cpp/language/enum">枚举类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><strong class="selflink">函数类型</strong></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">类/结构体类型</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="union.html" title="cpp/language/union">联合体类型</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">说明符</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="cv.html" title="cpp/language/cv"><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>/<span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="decltype.html" title="cpp/language/decltype"><tt>decltype</tt></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="auto.html" title="cpp/language/auto"><tt>auto</tt></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="constexpr.html" title="cpp/language/constexpr"><tt>constexpr</tt></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="consteval.html" title="cpp/language/consteval"><tt>consteval</tt></a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constinit.html" title="cpp/language/constinit"><tt>constinit</tt></a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="storage_duration.html" title="cpp/language/storage duration">存储期说明符</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="initialization.html" title="cpp/language/initialization">初始化</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_initialization.html" title="cpp/language/default initialization">默认初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="value_initialization.html" title="cpp/language/value initialization">值初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="zero_initialization.html" title="cpp/language/zero initialization">零初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_initialization.html" title="cpp/language/copy initialization">复制初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="direct_initialization.html" title="cpp/language/direct initialization">直接初始化</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">聚合初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="list_initialization.html" title="cpp/language/list initialization">列表初始化</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constant_initialization.html" title="cpp/language/constant initialization">常量初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reference_initialization.html" title="cpp/language/reference initialization">引用初始化</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
</table></div>
</div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"><a href="expressions.html" title="cpp/language/expressions">表达式</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="value_category.html" title="cpp/language/value category">值类别</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="eval_order.html" title="cpp/language/eval order">求值顺序</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="operators.html" title="cpp/language/operators">运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_precedence.html" title="cpp/language/operator precedence">运算符优先级</a></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_alternative.html" title="cpp/language/operator alternative">替代表示</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="expressions.html#.E5.AD.97.E9.9D.A2.E9.87.8F" title="cpp/language/expressions">字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="bool_literal.html" title="cpp/language/bool literal">布尔</a> - <a href="integer_literal.html" title="cpp/language/integer literal">整数</a> - <a href="floating_literal.html" title="cpp/language/floating literal">浮点</a></td></tr>   
<tr class="t-nv"><td colspan="5"><a href="character_literal.html" title="cpp/language/character literal">字符</a> - <a href="string_literal.html" title="cpp/language/string literal">字符串</a> - <a href="nullptr.html" title="cpp/language/nullptr"><tt>nullptr</tt></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr> 
<tr class="t-nv"><td colspan="5"><a href="user_literal.html" title="cpp/language/user literal">用户定义</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">工具</td></tr>
<tr class="t-nv"><td colspan="5"><a href="attributes.html" title="cpp/language/attributes">属性</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">类型</td></tr>
<tr class="t-nv"><td colspan="5"><a href="typedef.html" title="cpp/language/typedef"><code>typedef</code> 声明</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="type_alias.html" title="cpp/language/type alias">类型别名声明</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">类型转换</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="implicit_conversion.html" title="cpp/language/implicit conversion">隐式转换</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static_cast.html" title="cpp/language/static cast"><tt>static_cast</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="const_cast.html" title="cpp/language/const cast"><tt>const_cast</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="explicit_cast.html" title="cpp/language/explicit cast">显式转换</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="dynamic_cast.html" title="cpp/language/dynamic cast"><tt>dynamic_cast</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><tt>reinterpret_cast</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">内存分配</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="new.html" title="cpp/language/new"><code>new</code> 表达式</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="delete.html" title="cpp/language/delete"><code>delete</code> 表达式</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="classes.html" title="cpp/language/classes">类</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">类声明</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constructor.html" title="cpp/language/constructor">构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="this.html" title="cpp/language/this"><code>this</code> 指针</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="access.html" title="cpp/language/access">访问说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="friend.html" title="cpp/language/friend"><code>friend</code> 说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">类特有的函数性质</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="virtual.html" title="cpp/language/virtual">虚函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="override.html" title="cpp/language/override"><code>override</code> 说明符</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span>  </td></tr>
<tr class="t-nv"><td colspan="5"><a href="final.html" title="cpp/language/final"><code>final</code> 说明符</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="explicit.html" title="cpp/language/explicit"><tt>explicit</tt></a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static.html" title="cpp/language/static"><tt>static</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">特殊成员函数</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_constructor.html" title="cpp/language/default constructor">默认构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_constructor.html" title="cpp/language/copy constructor">复制构造函数</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_constructor.html" title="cpp/language/move constructor">移动构造函数</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="copy_assignment.html" title="cpp/language/copy assignment">复制赋值</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_assignment.html" title="cpp/language/move assignment">移动赋值</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="destructor.html" title="cpp/language/destructor">析构函数</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="templates.html" title="cpp/language/templates">模板</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class_template.html" title="cpp/language/class template">类模板</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function_template.html" title="cpp/language/function template">函数模板</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="template_specialization.html" title="cpp/language/template specialization">模板特化</a></td></tr>   
<tr class="t-nv"><td colspan="5"><a href="pack.html" title="cpp/language/pack">形参包</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">杂项</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="asm.html" title="cpp/language/asm">内联汇编</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="history.html" title="cpp/language/history">C++ 的历史</a></td></tr>
</table></div></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="functions.html" title="cpp/language/functions"> 函数</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5">声明</td></tr>
<tr class="t-nv"><td colspan="5"><strong class="selflink">函数声明</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html#.E5.BD.A2.E5.8F.82.E5.88.97.E8.A1.A8" title="cpp/language/function">函数形参列表</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html#.E5.87.BD.E6.95.B0.E5.AE.9A.E4.B9.89" title="cpp/language/function">函数定义</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html#.E5.87.BD.E6.95.B0.E5.A5.91.E7.BA.A6.E8.AF.B4.E6.98.8E.E7.AC.A6" title="cpp/language/function">函数契约说明符</a> <span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="default_arguments.html" title="cpp/language/default arguments">默认实参</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="variadic_arguments.html" title="cpp/language/variadic arguments">变长实参</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="inline.html" title="cpp/language/inline"><code>inline</code> 说明符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="lambda.html" title="cpp/language/lambda">lambda 表达式</a> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="coroutines.html" title="cpp/language/coroutines">协程</a> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="replacement_function.html" title="cpp/language/replacement function">替换函数</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">函数调用</td></tr>
<tr class="t-nv"><td colspan="5"><a href="adl.html" title="cpp/language/adl">实参依赖查找</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_other.html#.E5.86.85.E5.BB.BA.E7.9A.84.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8.E8.BF.90.E7.AE.97.E7.AC.A6" title="cpp/language/operator other">函数调用运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../named_req/FunctionObject.html" title="cpp/named req/FunctionObject">函数对象</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">重载</td></tr>
<tr class="t-nv"><td colspan="5"><a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operators.html" title="cpp/language/operators">运算符重载</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="overloaded_address.html" title="cpp/language/overloaded address">重载集的地址</a></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>函数声明引入函数名和它的类型。函数定义将函数名/类型与函数体关联起来。
</p>
<h3><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.A3.B0.E6.98.8E">函数声明</span></h3>
<p>函数声明可以在任何作用域出现。类作用域中的函数声明引入成员函数（除非使用 <span class="mw-geshi cpp source-cpp"><span class="kw1">friend</span></span> 说明符），细节见<a href="member_functions.html" title="cpp/language/member functions">成员函数</a>和<a href="friend.html" title="cpp/language/friend">友元函数</a>。
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">非指针声明符</span> <code><b>(</b></code> <span class="t-spar">形参列表</span> <code><b>)</b></code> <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">异常说明</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">非指针声明符</span> <code><b>(</b></code> <span class="t-spar">形参列表</span> <code><b>)</b></code> <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">异常说明</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span><br><code><b>-&gt;</b></code> <span class="t-spar">尾随返回类型</span>
</td>
<td> (2)
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<p>（<span class="t-spar">声明符</span> ﻿语法的其他形式见<a href="declarations.html" title="cpp/language/declarations">声明</a>页面）
</p>
<div class="t-li1"><span class="t-li">1)</span> 常规函数声明符语法。</div>
<div class="t-li1"><span class="t-li">2)</span> 尾随返回类型声明。这种情况中的<span class="t-spar">声明说明符序列</span> ﻿必须包含关键词 <span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span>。</div>
<table class="t-par-begin">


<tr class="t-par">
<td> <span class="t-spar">非指针声明符</span>
</td>
<td> -
</td>
<td> 任何合法的<span class="t-spar">声明符</span>，但如果它以 <code>*</code>、<code>&amp;</code> 或 <code>&amp;&amp;</code> 开始，那么它必须被括号环绕。
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">形参列表</span>
</td>
<td> -
</td>
<td> 函数形参的逗号分隔列表，可以为空（细节见下文）
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">属性</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span> <a href="attributes.html" title="cpp/language/attributes">属性</a>的列表。这些属性应用于函数的类型，而非函数自身。声明符中标识符之后出现的属性与声明开端出现的属性合并到一起，如果存在。
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">cv限定符</span>
</td>
<td> -
</td>
<td> const/volatile 限定，只能在非静态成员函数中使用
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">引用限定符</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span> 引用限定，只能在非静态成员函数中使用
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">异常说明</span>
</td>
<td> -
</td>
<td> <table class="t-rev-begin">
<tr class="t-rev t-until-cxx11"><td>
<p><a href="except_spec.html" title="cpp/language/except spec">动态异常说明</a>
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11" style="white-space: nowrap;">(C++11 前)</span></td></tr>
<tr class="t-rev t-since-cxx11 t-until-cxx17"><td>
<p><a href="except_spec.html" title="cpp/language/except spec">动态异常说明</a>或 <a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept 说明</a>
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span><br><span class="t-mark-rev t-until-cxx17" style="white-space: nowrap;">(C++17 前)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<p><a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept 说明</a>
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></td></tr>
</table>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">尾随返回类型</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span> 尾随返回类型，当返回类型取决于实参名时，例如 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> <span class="kw4">auto</span> add<span class="br0">(</span>T t, U u<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> decltype<span class="br0">(</span>t <span class="sy2">+</span> u<span class="br0">)</span><span class="sy4">;</span></span></span>，或当返回类型复杂时，例如在 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span> fpif<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw4">int</span><span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span></span></span> 中，尾随返回类型很有用
</td></tr></table>
<p><br>
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<p>如<a href="declarations.html#.E5.A3.B0.E6.98.8E.E7.AC.A6" title="cpp/language/declarations">声明</a>页面所示，声明符可以后随 <a href="constraints.html#requires_.E5.AD.90.E5.8F.A5" title="cpp/language/constraints"><span class="mw-geshi cpp source-cpp">requires</span> 子句</a>，它声明与该函数关联的<a href="constraints.html" title="cpp/language/constraints">约束</a>，而<a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a>所要选择的函数必须满足该制约。（例如 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">)</span> requires <span class="kw2">true</span><span class="sy4">;</span></span></span>）注意，关联的制约是函数签名的一部分，但不是函数类型的一部分。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></td></tr>
</table>
<p>只要<a href="declarations.html#.E8.AF.B4.E6.98.8E.E7.AC.A6" title="cpp/language/declarations">声明说明符序列</a>允许，函数声明符就可以和其他声明符混合：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// 声明一个 int、一个 int*、一个函数，及一个函数指针</span>
<span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">1</span>, <span class="sy2">*</span>p <span class="sy1">=</span> <a href="../types/NULL.html"><span class="kw110">NULL</span></a>, f<span class="br0">(</span><span class="br0">)</span>, <span class="br0">(</span><span class="sy2">*</span>pf<span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// 声明说明符序列 是 int</span>
<span class="co1">// 声明符 f() 声明（但不定义）一个不接受实参并返回 int 的函数</span>
 
<span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span> <span class="kw4">const</span>, g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span><span class="sy4">;</span> <span class="co1">// 声明两个非静态成员函数</span>
    <span class="kw1">virtual</span> <span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span>, x<span class="sy4">;</span> <span class="co1">// 编译时错误：（声明说明符序列中的）virtual</span>
                            <span class="co1">// 只能声明非静态成员函数</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<p>以 volatile 限定的对象类型作为形参类型或返回类型是被弃用的。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></td></tr>
</table>
<p>函数的返回类型不能是函数类型或数组类型（但可以是到它们的指针或引用）。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>与任何声明相同，声明前出现的属性和声明符中直接跟在标识符之后的属性都会应用到所声明或定义的实体（在这个例子中，应用到函数）：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="br0">[</span><span class="br0">[</span>noreturn<span class="br0">]</span><span class="br0">]</span> <span class="kw4">void</span> f <span class="br0">[</span><span class="br0">[</span>noreturn<span class="br0">]</span><span class="br0">]</span> <span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK：两个属性都应用到函数 f</span></pre></div></div>
<p>然而，（按上述语法）在声明符后出现的属性会应用到函数类型而非函数自身：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">[</span><span class="br0">[</span>noreturn<span class="br0">]</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// 错误：此属性对函数自身没有影响</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
<tr class="t-rev t-since-cxx14"><td>
<h3> <span class="mw-headline" id=".E8.BF.94.E5.9B.9E.E7.B1.BB.E5.9E.8B.E6.8E.A8.E5.AF.BC">返回类型推导</span></h3>
<p>如果函数声明的<span class="t-spar">声明说明符序列</span> ﻿包含关键词 <span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span>，那么尾随返回类型可以省略，且编译器将从返回语句中所用的表达式的类型推导出它。如果返回类型没有使用 <span class="mw-geshi cpp source-cpp">decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span></span>，那么推导遵循<a href="template_argument_deduction.html#.E5.85.B6.E4.BB.96.E8.AF.AD.E5.A2.83" title="cpp/language/template argument deduction">模板实参推导</a>的规则进行：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw4">auto</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> x<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// 返回类型是 int</span>
<span class="kw4">const</span> <span class="kw4">auto</span><span class="sy3">&amp;</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> x<span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 返回类型是 const int&amp;</span></pre></div></div>
<p>如果返回类型是 <span class="mw-geshi cpp source-cpp">decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span></span>，那么返回类型是将返回语句中所用的表达式包裹到 <a href="decltype.html" title="cpp/language/decltype"><code>decltype</code></a> 中时所得到的类型：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> x<span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// 返回类型是 int，同 decltype(x)</span>
decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 返回类型是 int&amp;，同 decltype((x))</span></pre></div></div>
<p>（注意：“<span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span><span class="sy3">&amp;</span></span>”是错误的，<span class="mw-geshi cpp source-cpp">decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span></span> 必须独自使用）
</p><p>如果有多条返回语句，那么它们必须推导出相同的类型：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> f<span class="br0">(</span><span class="kw4">bool</span> val<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>val<span class="br0">)</span> <span class="kw1">return</span> <span class="nu0">123</span><span class="sy4">;</span> <span class="co1">// 推导出返回类型 int</span>
    <span class="kw1">else</span> <span class="kw1">return</span> <span class="nu17">3.14f</span><span class="sy4">;</span>  <span class="co1">// 错误：推导出返回类型 float</span>
<span class="br0">}</span></pre></div></div>
<p>如果没有返回语句或返回语句的实参是 void 表达式，那么所声明的返回类型，必须要么是 <span class="mw-geshi cpp source-cpp">decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span></span>，此时推导返回类型是 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>，要么是（可有 cv 限定的）<span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span>，此时推导的返回类型是（具有相同 cv 限定的）<span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>              <span class="co1">// 返回 void</span>
<span class="kw4">auto</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 返回 void</span>
<span class="kw4">auto</span><span class="sy2">*</span> x<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>             <span class="co1">// 错误: 不能从 void 推导 auto*</span></pre></div></div>
<p>一旦在函数中见到一条返回语句，那么从该语句推导的返回类型就可以用于函数的剩余部分，包括其他返回语句：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> sum<span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>i <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> i<span class="sy4">;</span>              <span class="co1">// sum 的返回类型是 int</span>
    <span class="kw1">else</span>
        <span class="kw1">return</span> sum<span class="br0">(</span>i <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy2">+</span> i<span class="sy4">;</span> <span class="co1">// OK，sum 的返回类型已知</span>
<span class="br0">}</span></pre></div></div>
<p>如果返回语句使用<a href="initialization.html" title="cpp/language/initialization">花括号包围的初始化器列表</a>，那么就不能推导：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> func<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 错误</span></pre></div></div>
<p><a href="virtual.html" title="cpp/language/virtual">虚函数</a><span class="t-rev-inl t-since-cxx20"><span>与<a href="coroutines.html" title="cpp/language/coroutines">协程</a></span><span><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></span></span>不能使用返回类型推导：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> F
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">auto</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="nu0">2</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 错误</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>除了<a href="cast_operator.html" title="cpp/language/cast operator">用户定义转换函数</a>以外的<a href="function_template.html" title="cpp/language/function template">函数模板</a>可以使用返回类型推导。即使返回语句中的表达式并非<a href="dependent_name.html" title="cpp/language/dependent name">待决</a>，推导也在实例化时发生。这种实例化并不处于 <a href="sfinae.html" title="cpp/language/sfinae">SFINAE</a> 的目的的立即语境中。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">auto</span> f<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> t<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw1">typedef</span> decltype<span class="br0">(</span>f<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span> fint_t<span class="sy4">;</span>    <span class="co1">// 实例化 f&lt;int&gt; 以推导返回类型</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">auto</span> f<span class="br0">(</span>T<span class="sy2">*</span> t<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="sy2">*</span>t<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>f<span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// 实例化两个 f 以确定返回类型，</span>
                                  <span class="co1">// 选择第二个模板重载</span></pre></div></div>
<p>使用返回类型推导的函数或函数模板的重声明或特化必须使用同一返回类型占位符：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> f<span class="br0">(</span><span class="kw4">int</span> num<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> num<span class="sy4">;</span> <span class="br0">}</span>
<span class="co1">// int f(int num);            // 错误：返回类型未使用占位符</span>
<span class="co1">// decltype(auto) f(int num); // 错误：占位符不同</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">auto</span> g<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> t<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw1">template</span> <span class="kw4">auto</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// OK：返回类型是 int</span>
<span class="co1">// template char g(char); // 错误：不是主模板 g 的特化</span></pre></div></div>
<p>反过来也一样：不使用返回类型推导的函数或函数模板的重声明或特化不能使用返回类型占位符：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> num<span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// auto f(int num) { return num; } // 错误：不是 f 的重声明</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
T g<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> t<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw1">template</span> <span class="kw4">int</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>      <span class="co1">// OK：特化 T 为 int</span>
<span class="co1">// template auto g(char); // 错误：不是主模板 g 的特化</span></pre></div></div>
<p><a href="function_template.html#.E6.98.BE.E5.BC.8F.E5.AE.9E.E4.BE.8B.E5.8C.96" title="cpp/language/function template">显式实例化声明</a>本身并不会实例化使用返回类型推导的函数模板：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">auto</span> f<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> t<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw4">extern</span> <span class="kw1">template</span> <span class="kw4">auto</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 不会实例化 f&lt;int&gt;</span>
 
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// 实例化 f&lt;int&gt; 以确定它的返回类型，</span>
                   <span class="co1">// 但仍需要在程序的别处出现显式实例化的定义</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14" style="white-space: nowrap;">(C++14 起)</span></td></tr>
</table>
<h3><span class="mw-headline" id=".E5.BD.A2.E5.8F.82.E5.88.97.E8.A1.A8">形参列表</span></h3>
<p>形参列表决定调用函数时所能指定的实参。它是<i>形参声明</i> ﻿的逗号分隔列表，其中每一项拥有下列语法：
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> <span class="t-spar">声明符</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span id=".E7.89.88.E6.9C.AC_2"></span>
<p><span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>this</b></code> <span class="t-spar">声明说明符序列</span> <span class="t-spar">声明符</span>
</p>
</td>
<td> (2)
</td>
<td> <span class="t-mark-rev t-since-cxx23" style="white-space: nowrap;">(C++23 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> <span class="t-spar">声明符</span> <code><b>=</b></code> <span class="t-spar">初始化器</span>
</td>
<td> (3)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> <span class="t-spar">抽象声明符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span>
</td>
<td> (4)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span id=".E7.89.88.E6.9C.AC_5"></span>
<p><span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>this</b></code> <span class="t-spar">声明说明符序列</span> <span class="t-spar">抽象声明符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span>
</p>
</td>
<td> (5)
</td>
<td> <span class="t-mark-rev t-since-cxx23" style="white-space: nowrap;">(C++23 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> <span class="t-spar">抽象声明符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>=</b></code> <span class="t-spar">初始化器</span>
</td>
<td> (6)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>void</b></code>
</td>
<td> (7)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<div class="t-li1"><span class="t-li">1)</span> 声明一个具名（形式）参数。<span class="t-spar">声明说明符序列</span> ﻿和<span class="t-spar">声明符</span> ﻿的含义见<a href="declarations.html" title="cpp/language/declarations">声明</a>页面。</div>
<div class="t-li1"><span class="t-li"></span> <span class="t-cc"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span><span class="sy2">*</span> p, <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">(</span><span class="sy2">*</span>x<span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">2)</span> 声明一个具名<a href="function.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82">显式对象形参</a>。</div>
<div class="t-li1"><span class="t-li">3)</span> 声明一个带有<a href="default_arguments.html" title="cpp/language/default arguments">默认值</a>的具名（形式）参数。</div>
<div class="t-li1"><span class="t-li"></span> <span class="t-cc"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">7</span>, <span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> nullptr, <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">(</span><span class="sy2">*</span>x<span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> nullptr<span class="br0">)</span><span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">4)</span> 声明一个无名形参。</div>
<div class="t-li1"><span class="t-li"></span> <span class="t-cc"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy2">*</span>, <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">5)</span> 声明一个无名<a href="function.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82">显式对象形参</a>。</div>
<div class="t-li1"><span class="t-li">6)</span> 声明一个具有<a href="default_arguments.html" title="cpp/language/default arguments">默认值</a>的无名形参。</div>
<div class="t-li1"><span class="t-li"></span> <span class="t-cc"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> <span class="sy1">=</span> <span class="nu0">7</span>, <span class="kw4">int</span><span class="sy2">*</span> <span class="sy1">=</span> nullptr, <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> nullptr<span class="br0">)</span><span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">7)</span> 指示函数不接受形参，它是空形参列表的确切同义词：<span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy4">;</span></span></span> 和 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span> 声明同一函数。</div>
<div class="t-li1"><span class="t-li"></span> 只有 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span></span> 这一种形式与空形参列表等价，<span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 形参的其他用法非良构：
<table class="wikitable">
<tr>
<th>错误用法
</th>
<th>示例
</th></tr>
<tr>
<td>存在多个形参
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f1<span class="br0">(</span><span class="kw4">void</span>, <span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 形参具名
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">inf f2<span class="br0">(</span><span class="kw4">void</span> param<span class="br0">)</span><span class="sy4">;</span></span></span>
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 具有 cv 限定
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f3<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">void</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 是<a href="dependent_name.html" title="cpp/language/dependent name">待决</a>的
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f4<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span></span></span> (where <code>T</code> is <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>)
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 形参是<a href="function.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82">显式对象形参</a> <span class="t-mark-rev t-since-cxx23" style="white-space: nowrap;">(C++23 起)</span>
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> f5<span class="br0">(</span>this <span class="kw4">void</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</td></tr></table></div>
<table class="t-rev-begin">
<tr class="t-rev t-until-cxx17"><td>
<p>尽管<span class="t-spar">声明说明符序列</span> ﻿暗示可以存在类型说明符之外的<a href="declarations.html#.E8.AF.B4.E6.98.8E.E7.AC.A6" title="cpp/language/declarations">说明符</a>，但可用的其他说明符只有 <span class="mw-geshi cpp source-cpp"><span class="kw4">register</span></span> <span class="t-rev-inl t-until-cxx11"><span>和 <span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span></span><span><span class="t-mark-rev t-until-cxx11" style="white-space: nowrap;">(C++11 前)</span></span></span>，而且它没有任何效果。
</p>
</td>
<td><span class="t-mark-rev t-until-cxx17" style="white-space: nowrap;">(C++17 前)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<p>如果任何函数形参使用了<i>占位符</i>（<span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span> 或 <a href="../concepts.html" title="cpp/concepts">概念类型</a>），那么函数声明转变为<a href="function_template.html#.E7.AE.80.E5.86.99.E5.87.BD.E6.95.B0.E6.A8.A1.E6.9D.BF" title="cpp/language/function template">简写函数模板</a>声明：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// 同 template&lt;class T&gt; void f(T)</span>
<span class="kw4">void</span> f2<span class="br0">(</span>C1 <span class="kw4">auto</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 如果 C1 是概念，同 template&lt;C1 T&gt; void f7(T)</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<p><span id=".E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82"></span>
带说明符 <span class="mw-geshi cpp source-cpp">this</span> 的形参声明（形式 <span class="t-v">(<a href="function.html#.E7.89.88.E6.9C.AC_2">2</a>)</span>/<span class="t-v">(<a href="function.html#.E7.89.88.E6.9C.AC_5">5</a>)</span>）声明的是<i>显式对象形参</i>。
</p><p>显式对象形参不能是<a href="pack.html" title="cpp/language/pack">函数形参包</a>，并且只能作为以下声明中的形参列表的首个形参：
</p>
<ul><li> <a href="member_functions.html" title="cpp/language/member functions">成员函数</a>或成员函数模板声明
</li><li> 模板化成员函数的<a href="function_template.html#.E6.98.BE.E5.BC.8F.E5.AE.9E.E4.BE.8B.E5.8C.96" title="cpp/language/function template">显式实例化</a>或<a href="template_specialization.html" title="cpp/language/template specialization">显式特化</a>
</li><li> <a href="lambda.html" title="cpp/language/lambda">lambda</a> 声明
</li></ul>
<p>有显式对象形参的成员函数具有以下限制：
</p>
<ul><li> 该函数不是<a href="static.html" title="cpp/language/static">静态</a>函数。
</li><li> 该函数不是<a href="virtual.html" title="cpp/language/virtual">虚</a>函数。
</li><li> 该函数的<a href="function.html#.E5.87.BD.E6.95.B0.E5.A3.B0.E6.98.8E">声明</a>不含 <span class="t-spar">cv限定符</span> ﻿和<span class="t-spar">引用限定符</span>。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span>this C<span class="sy3">&amp;</span> self<span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// OK</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> Self<span class="sy1">&gt;</span>
    <span class="kw4">void</span> g<span class="br0">(</span>this Self<span class="sy3">&amp;&amp;</span> self<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 模板也 OK</span>
 
    <span class="kw4">void</span> p<span class="br0">(</span>this C<span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span>     <span class="co1">// 错误：此处不允许使用 “const”</span>
    <span class="kw4">static</span> <span class="kw4">void</span> q<span class="br0">(</span>this C<span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// 错误：此处不允许使用 “static”</span>
    <span class="kw4">void</span> r<span class="br0">(</span><span class="kw4">int</span>, this C<span class="br0">)</span><span class="sy4">;</span>      <span class="co1">// 错误：显式对象形参只能是首个形参</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// void func(this C&amp; self);   // 错误：非成员函数不能有显式对象形参</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx23" style="white-space: nowrap;">(C++23 起)</span></td></tr>
</table>
<p>函数声明中声明的形参名通常只用作以自身为文档。它们在函数定义中被使用（但仍不强制）。
</p><p>当类型名称被圆括号包围时<span class="t-rev-inl t-since-cxx11"><span>（包括 <a href="lambda.html" title="cpp/language/lambda">lambda 表达式</a>）</span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>会产生歧义。此时可以解析成类型是函数指针的形参的声明以及<span class="t-spar">声明符</span> ﻿中的标识符被额外的圆括号包围的形参的声明。解决方案是将该类型名称视为<a href="declarations.html#.E8.AF.B4.E6.98.8E.E7.AC.A6" title="cpp/language/declarations">简单类型说明符</a>（此时它即是函数指针类型）：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">class</span> C <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">(</span>C<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// void f(int(*fp)(C param)) {}</span>
                  <span class="co1">// 不是 void f(int C) {}</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span><span class="br0">(</span>C<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// void g(int *(*fp)(C param[10]));</span>
                      <span class="co1">// 不是 void g(int *C[10]);</span></pre></div></div>
<p>形参类型不能是含有到未知边界数组的引用或指针的类型，含有这种类型的多级指针/数组，或含有指向以这些类型为形参的函数的指针。
</p>
<h4><span class="mw-headline" id=".E4.BD.BF.E7.94.A8.E7.9C.81.E7.95.A5.E5.8F.B7">使用省略号</span></h4>
<p>形参列表的最后一个形参可以是省略号（<span class="t-c"><span class="mw-geshi cpp source-cpp">...</span></span>）；这会声明一个<a href="variadic_arguments.html" title="cpp/language/variadic arguments">变参函数</a><span class="t-rev-inl">位于省略号前的逗号可以省略<span class="t-mark-rev t-deprecated-cxx26" style="white-space: nowrap;">(C++26 弃用)</span></span>：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> printf<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> fmt, ...<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 变参函数</span>
<span class="kw4">int</span> printf<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> fmt...<span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// 同上，但 C++26 起被弃用</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>Args..., ...<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 带形参包的变参函数模板</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>Args... ...<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 同上，但 C++26 起被弃用</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>Args......<span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// 同上，但 C++26 起被弃用</span></pre></div></div>
<h3><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E7.B1.BB.E5.9E.8B">函数类型</span></h3>
<h4><span class="mw-headline" id=".E5.BD.A2.E5.8F.82.E7.B1.BB.E5.9E.8B.E5.88.97.E8.A1.A8">形参类型列表</span></h4>
<p>函数的<i>形参类型列表</i> ﻿按以下方式确定：
</p>
<ol><li> 每个形参<span class="t-rev-inl t-since-cxx11"><span>（包括<a href="pack.html" title="cpp/language/pack">形参包</a>）</span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>的类型通过形参自身的<a href="function.html#.E5.BD.A2.E5.8F.82.E5.88.97.E8.A1.A8">声明</a>确定。
</li><li> 在确定每个形参的类型后，类型是 “<code>T</code> 的数组”或某个函数类型 <code>T</code> 的形参会调整为具有类型“指向 <code>T</code> 的指针”。
</li><li> 在产生形参类型的列表后，在组成函数类型时会移除所有修改了形参类型的顶层 <a href="cv.html" title="cpp/language/cv">cv 限定符</a>。
</li><li> 转换后的形参类型的列表，加上是否有出现<a href="function.html#.E4.BD.BF.E7.94.A8.E7.9C.81.E7.95.A5.E5.8F.B7">省略号</a><span class="t-rev-inl t-since-cxx11"><span>或者<a href="pack.html" title="cpp/language/pack">形参包</a></span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>的特征共同组成了函数的形参类型列表。
</li></ol>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">char</span><span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>         <span class="co1">// #1</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">char</span><span class="br0">[</span><span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>      <span class="co1">// 定义了 #1</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// OK，另一重载</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">char</span><span class="sy2">*</span> <span class="kw4">const</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 错误：重定义了 #1</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">char</span><span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// #2</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">char</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 定义了 #2</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">char</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// OK，另一重载</span>
 
<span class="kw4">void</span> h<span class="br0">(</span><span class="kw4">int</span> x<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #3</span>
<span class="kw4">void</span> h<span class="br0">(</span><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>   <span class="co1">// 定义了 #3</span></pre></div></div>
<h4><span class="mw-headline" id=".E7.A1.AE.E5.AE.9A.E5.87.BD.E6.95.B0.E7.B1.BB.E5.9E.8B">确定函数类型</span></h4>
<p>在语法 <span class="t-v">(1)</span> 中，在假设<span class="t-spar">非指针声明符</span> ﻿是独立声明的情况下，给定<span class="t-spar">非指针声明符</span> ﻿中<span class="t-spar">有限定标识</span> ﻿或<span class="t-spar">无限定标识</span> ﻿的类型为“<code>T</code> 派生的声明符类型列表”：
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx17"><td>
<ul><li> 如果异常说明是<a href="noexcept_spec.html" title="cpp/language/noexcept spec">不抛出</a>的，那么声明的函数的类型是<br>“返回 <code>T</code> 的 <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span>接受形参类型列表的 <span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> 函数 派生的声明符类型列表”。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></td></tr>
</table>
<ul><li> <span class="t-rev-inl t-since-cxx17"><span>否则，</span><span><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></span></span>声明的函数的类型是<br>“返回 <code>T</code> 的 <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span><span class="t-rev-inl t-since-cxx11"><span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span></span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>接受形参类型列表的函数 派生的声明符类型列表”。
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>在语法 <span class="t-v">(2)</span> 中，在假设<span class="t-spar">非指针声明符</span> ﻿是独立声明的情况下，给定<span class="t-spar">非指针声明符</span> ﻿中<span class="t-spar">有限定标识</span> ﻿或<span class="t-spar">无限定标识</span> ﻿的类型为“<code>T</code> 派生的声明符类型列表”（此时 <code>T</code> 只能是 <span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span>）：
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<ul><li> 如果异常说明是<a href="noexcept_spec.html" title="cpp/language/noexcept spec">不抛出</a>的，那么声明的函数的类型是<br>“返回<span class="t-spar">尾随返回类型</span> ﻿的 <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span><br>接受形参类型列表的 <span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> 函数 派生的声明符类型列表”。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<ul><li> <span class="t-rev-inl t-since-cxx17"><span>否则，</span><span><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></span></span>声明的函数的类型是<br>“返回<span class="t-spar">尾随返回类型</span> ﻿的 <span class="t-spar">cv限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">引用限定符</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span>接受形参类型列表的函数 派生的声明符类型列表”。
</li></ul>
<p>存在<span class="t-spar">属性</span> ﻿时，它会应用到函数类型。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
</table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// f1 的类型是“返回 void 的接受 int 的函数，带有属性 noreturn”</span>
<span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">)</span> <span class="br0">[</span><span class="br0">[</span>noreturn<span class="br0">]</span><span class="br0">]</span><span class="sy4">;</span>
 
<span class="co1">// f2 的类型是“返回 int 的接受指向 int 的指针的 constexpr noexcept 函数”</span>
<span class="kw4">constexpr</span> <span class="kw4">auto</span> f2<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> b<span class="br0">)</span> <span class="kw1">noexcept</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">int</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> X
<span class="br0">{</span>
    <span class="co1">// f3 的类型是“返回 const int 的 const 的不接受参数的函数”</span>
    <span class="kw4">const</span> <span class="kw4">int</span> f3<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.B0.BE.E9.9A.8F.E9.99.90.E5.AE.9A.E7.AC.A6">尾随限定符</span></h4>
<p>有 <span class="t-spar">cv限定符</span> ﻿<span class="t-rev-inl t-since-cxx11"><span>或<span class="t-spar">引用限定符</span> ﻿</span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>的函数类型(包括以 <a href="typedef.html" title="cpp/language/typedef"><code>typedef</code></a> 名命名的类型)只能作为以下类型出现：
</p>
<ul><li> <a href="member_functions.html" title="cpp/language/member functions">非静态成员函数</a>的类型。
</li><li> 成员指针指代的函数类型。
</li><li> 函数 <span class="mw-geshi cpp source-cpp"><span class="kw1">typedef</span></span> 声明<span class="t-rev-inl t-since-cxx11"><span>或<a href="type_alias.html" title="cpp/language/type alias">别名声明</a></span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>的顶层函数类型。
</li><li> <a href="template_parameters.html#.E6.A8.A1.E6.9D.BF.E7.B1.BB.E5.9E.8B.E5.BD.A2.E5.8F.82" title="cpp/language/template parameters">模板类型形参</a>的默认实参中的<a href="type.html#.E7.B1.BB.E5.9E.8B.E7.9A.84.E5.91.BD.E5.90.8D" title="cpp/language/type">类型标识</a>。
</li><li> 模板类型形参对应的模板实参的类型标识。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">typedef</span> <span class="kw4">int</span> FIC<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span>
FIC f<span class="sy4">;</span>     <span class="co1">// 错误：声明的不是成员函数</span>
 
<span class="kw1">struct</span> S
<span class="br0">{</span>
    FIC f<span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span><span class="sy4">;</span>
 
FIC S<span class="sy4">::</span><span class="sy2">*</span>pm <span class="sy1">=</span> <span class="sy3">&amp;</span>S<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span> <span class="co1">// OK</span></pre></div></div>
<h3><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E7.AD.BE.E5.90.8D">函数签名</span></h3>
<p>每个函数都有一个签名。
</p><p>函数签名包含函数的名字和<a href="function.html#.E5.BD.A2.E5.8F.82.E7.B1.BB.E5.9E.8B.E5.88.97.E8.A1.A8">形参类型列表</a>。除以下情况外，函数签名也包含函数的外围<a href="namespace.html" title="cpp/language/namespace">命名空间</a>：
</p>
<ul><li> 如果函数是<a href="member_functions.html" title="cpp/language/member functions">成员函数</a>，那么它的签名会包含以该函数为成员的类而非它的外围命名空间。它的签名也包含以下组分（如果存在）：
</li></ul>
<dl><dd><ul><li> <span class="t-spar">cv限定符</span>
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<dl><dd><ul><li> <span class="t-spar">引用限定符</span>
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<dl><dd><ul><li> 尾随 <span class="mw-geshi cpp source-cpp">requires</span> 子句
</li></ul>
</dd></dl>
<ul><li> 如果函数是带尾随 <span class="mw-geshi cpp source-cpp">requires</span> 子句的非模板<a href="friend.html" title="cpp/language/friend">友元</a>函数，那么它的签名会包含它的外围类而非它的外围命名空间。签名也会包含该尾随 <span class="mw-geshi cpp source-cpp">requires</span> 子句。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></td></tr>
</table>
<p><span class="t-spar">异常说明</span> ﻿<span class="t-rev-inl t-since-cxx11"><span>和<span class="t-spar">属性</span></span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>不是函数签名的一部分<span class="t-rev-inl t-since-cxx17"><span>，尽管 <a href="noexcept_spec.html" title="cpp/language/noexcept spec"><span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span> 说明</a>会影响函数类型</span><span><span class="t-mark-rev t-since-cxx17" style="white-space: nowrap;">(C++17 起)</span></span></span>。
</p>
<h3><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.AE.9A.E4.B9.89">函数定义</span></h3>
<p>非成员函数的定义只能在命名空间作用域中出现（不存在嵌套函数）。<a href="member_functions.html" title="cpp/language/member functions">成员函数</a>的定义也可以在<a href="class.html" title="cpp/language/class">类定义</a>的体内出现。它们拥有下列语法：
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明符</span> <span class="t-spar">虚说明</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">契约说明</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">函数体</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明说明符序列</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">声明符</span> <span class="t-spar">requires子句</span> <span class="t-spar">契约说明</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">函数体</span>
</td>
<td> (2)
</td>
<td> <span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<div class="t-li1"><span class="t-li">1)</span> 没有约束的函数定义。</div>
<div class="t-li1"><span class="t-li">2)</span> 有约束的函数定义。</div>
<table class="t-par-begin">


<tr class="t-par">
<td> <span class="t-spar">属性</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span> <a href="attributes.html" title="cpp/language/attributes">属性</a>的列表。这些属性与可能出现在<span class="t-spar">声明符</span> ﻿中标识符之后的属性（见本页顶部）合并到一起。
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">声明说明符序列</span>
</td>
<td> -
</td>
<td> 带有说明符的返回类型，与<a href="declarations.html" title="cpp/language/declarations">声明文法</a>相同
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">声明符</span>
</td>
<td> -
</td>
<td> 函数声明符，与上述函数声明语法相同（可以被圆括号包围）
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">虚说明</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span> <a href="override.html" title="cpp/language/override"><code>override</code></a>、<a href="final.html" title="cpp/language/final"><code>final</code></a>，或它们任意顺序的组合（只能用于非静态成员函数）
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">requires子句</span>
</td>
<td> -
</td>
<td> <a href="constraints.html#requires_.E5.AD.90.E5.8F.A5" title="cpp/language/constraints"><span class="mw-geshi cpp source-cpp">requires</span> 子句</a>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">契约说明</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span> <a href="function.html#.E5.87.BD.E6.95.B0.E5.A5.91.E7.BA.A6.E8.AF.B4.E6.98.8E.E7.AC.A6">函数契约说明符</a>的列表
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">函数体</span>
</td>
<td> -
</td>
<td> 函数体（见下文）
</td></tr></table>
<p><br>
<span class="t-spar">函数体</span> ﻿是下列之一：
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">构造函数初始化器</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <span class="t-spar">复合语句</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">函数try块</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>=</b></code> <code><b>default</b></code> <code><b>;</b></code>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>=</b></code> <code><b>delete</b></code> <code><b>;</b></code>
</td>
<td> (4)
</td>
<td> <span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>=</b></code> <code><b>delete</b></code> <code><b>(</b></code> <span class="t-spar">字符串字面量</span> <code><b>);</b></code>
</td>
<td> (5)
</td>
<td> <span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<div class="t-li1"><span class="t-li">1)</span> 常规函数体。</div>
<div class="t-li1"><span class="t-li">2)</span> <a href="try.html#.E5.87.BD.E6.95.B0_try_.E5.9D.97" title="cpp/language/try">函数 <span class="mw-geshi cpp source-cpp"><span class="kw1">try</span></span> 块</a>。</div>
<div class="t-li1"><span class="t-li">3)</span> 显式预置的函数定义。</div>
<div class="t-li1"><span class="t-li">4)</span> 显式弃置的函数定义。</div>
<div class="t-li1"><span class="t-li">5)</span> 显式弃置的函数定义，带有错误消息。</div>
<table class="t-par-begin">


<tr class="t-par">
<td> <span class="t-spar">构造函数初始化器</span>
</td>
<td> -
</td>
<td> <a href="constructor.html" title="cpp/language/initializer list" class="mw-redirect">成员初始化器列表</a>，只能用于构造函数
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">复合语句</span>
</td>
<td> -
</td>
<td> 花括号环绕的<a href="statements.html#.E5.A4.8D.E5.90.88.E8.AF.AD.E5.8F.A5" title="cpp/language/statements">语句序列</a>，它们构成函数体
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">函数try块</span>
</td>
<td> -
</td>
<td> <a href="try.html#.E5.87.BD.E6.95.B0_try_.E5.9D.97" title="cpp/language/try">函数 <span class="mw-geshi cpp source-cpp"><span class="kw1">try</span></span> 块</a>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">字符串字面量</span>
</td>
<td> -
</td>
<td> <a href="string_literal.html#.E4.B8.8D.E6.B1.82.E5.80.BC.E5.AD.97.E7.AC.A6.E4.B8.B2" title="cpp/language/string literal">不求值字符串字面量</a>，可以用于解释函数为何被弃置的理由
</td></tr></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> c<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> m <span class="sy1">=</span> <span class="br0">(</span>a <span class="sy1">&gt;</span> b<span class="br0">)</span> <span class="sy4">?</span> a <span class="sy4">:</span> b<span class="sy4">;</span>
    <span class="kw1">return</span> <span class="br0">(</span>m <span class="sy1">&gt;</span> c<span class="br0">)</span> <span class="sy4">?</span> m <span class="sy4">:</span> c<span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 声明说明符序列是“int”</span>
<span class="co1">// 声明符是“max(int a, int b, int c)”</span>
<span class="co1">// 函数体是 { ... }</span></pre></div></div>
<p>函数体是一条<a href="statements.html#.E5.A4.8D.E5.90.88.E8.AF.AD.E5.8F.A5" title="cpp/language/statements">复合语句</a>（由一对花括号环绕的零或多条语句），它们在函数调用时被执行。<a href="constructor.html" title="cpp/language/constructor">构造函数</a>的函数体还包括以下内容：
</p>
<ul><li> 对于所有标识符未在该构造函数的<a href="constructor.html" title="cpp/language/constructor">成员初始化器列表</a>中出现的非静态数据成员，用于初始化对应成员<a href="object.html#.E5.AD.90.E5.AF.B9.E8.B1.A1" title="cpp/language/object">子对象</a>的<span class="t-rev-inl t-since-cxx11"><span><a href="data_members.html#.E6.88.90.E5.91.98.E5.88.9D.E5.A7.8B.E5.8C.96" title="cpp/language/data members">默认成员初始化式</a>或</span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span><a href="default_initialization.html" title="cpp/language/default initialization">默认初始化</a>。
</li><li> 对于所有类型名未在该构造函数的成员初始化器列表中出现的基类，用于初始化对应基类子对象的默认初始化。
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>如果函数定义包含了<span class="t-spar">虚说明</span>，那么定义的必须是<a href="member_functions.html" title="cpp/language/member functions">成员函数</a>。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<p>如果函数定义包含了 <span class="t-spar">requires子句</span>，那么定义的必须是<a href="templates.html#.E6.A8.A1.E6.9D.BF.E5.8C.96.E5.AE.9E.E4.BD.93" title="cpp/language/templates">模板化函数</a>。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></td></tr>
</table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> override <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 错误：不是成员函数</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span> requires <span class="br0">(</span>sizeof<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">4</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 错误：不是模板化函数</span></pre></div></div>
<p>函数的各个形参类型和返回类型不能是（可有 cv 限定的）<a href="type.html" title="cpp/language/incomplete type" class="mw-redirect">不完整的</a><a href="class.html" title="cpp/language/class">类类型</a>，<span class="t-rev-inl t-since-cxx11"><span>除非函数已显式定义为被弃置</span><span><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></span></span>。完整性检查只会在函数体中进行，因此<a href="member_functions.html" title="cpp/language/member functions">成员函数</a>可以返回在其中定义它们的类（或它的外围类），尽管在定义点它可能不完整（它在函数体内完整）。
</p><p>在函数定义的<span class="t-spar">声明符</span> ﻿中声明的形参在函数体内<a href="scope.html" title="cpp/language/scope">处于作用域中</a>。如果某个形参没有在函数体中使用，那么它不需要具名（只需要使用抽象声明符）：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span><span class="br0">)</span> <span class="co1">// 没有使用第二个形参</span>
<span class="br0">{</span>
    <a href="../io/c/fprintf.html"><span class="kw1849">std::<span class="me2">printf</span></span></a><span class="br0">(</span><span class="st0">"a = %d<span class="es1">\n</span>"</span>, a<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>尽管形参上的顶层 <a href="cv.html" title="cpp/language/cv">cv 限定符</a>在函数声明中被忽略，它们仍然会修饰形参的类型，这在函数体中可见：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span> n<span class="br0">)</span> <span class="co1">// 声明 void(int) 类型的函数</span>
<span class="br0">{</span>
    <span class="co1">// 但在体内，n 的类型是 const int</span>
<span class="br0">}</span></pre></div></div>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<h4> <span class="mw-headline" id=".E9.A2.84.E7.BD.AE.E5.87.BD.E6.95.B0">预置函数</span></h4>
<p>如果函数定义具有语法 <span class="t-v">(<a href="function.html#.E7.89.88.E6.9C.AC_3">3</a>)</span>，那么该函数被定义为<i>显式预置的</i>。
</p><p>显式预置的函数必须是<a href="member_functions.html#.E7.89.B9.E6.AE.8A.E6.88.90.E5.91.98.E5.87.BD.E6.95.B0" title="cpp/language/member functions">特殊成员函数</a><span class="t-rev-inl t-since-cxx20"><span>或<a href="operator_comparison.html" title="cpp/language/operator comparison">比较运算符函数</a></span><span><span class="t-mark-rev t-since-cxx20" style="white-space: nowrap;">(C++20 起)</span></span></span>，并且不能有<a href="default_arguments.html" title="cpp/language/default arguments">默认实参</a>。
</p><p>显式预置的特殊成员函数 <code>F1</code> 与对应的隐式声明版本 <code>F2</code> 可以有以下不同：
</p>
<ul><li> <code>F1</code> 与 <code>F2</code> 的<span class="t-spar">引用限定符</span> ﻿和/或<span class="t-spar">异常说明</span>可以不同。
</li><li> 如果 <code>F2</code> 有一个 <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> C<span class="sy3">&amp;</span></span> 类型的非对象形参，那么 <code>F1</code> 对应的非对象形参的类型可以是 <code>C&amp;</code>。
</li></ul>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx23"><td>
<ul><li> 如果 <code>F2</code> 有一个“到 <code>C</code> 的引用”类型的隐式对象形参，那么 <code>F1</code> 可以是有一个（可以不同的）“到 <code>C</code> 的引用”类型的<a href="function.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82">显式对象形参</a>的显式对象成员函数，这种情况下 <code>F1</code> 的类型可以因为多了一个形参而与 <code>F2</code> 的类型不同。
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx23" style="white-space: nowrap;">(C++23 起)</span></td></tr>
</table>
<p>如果 <code>F1</code> 与 <code>F2</code> 的类型因为先前规则以外的原因不同，那么：
</p>
<ul><li> 如果 <code>F1</code> 是赋值运算符，并且 <code>F1</code> 与 <code>F2</code> 的返回类型不同或 <code>F1</code> 的非对象形参类型不是引用，那么程序非良构。
</li><li> 否则，如果 <code>F1</code> 在它的首个声明被显式预置，那么它会被定义为弃置。
</li><li> 否则程序非良构。
</li></ul>
<p>在首个声明被显式预置的函数隐式<a href="inline.html" title="cpp/language/inline">内联</a>，并且在它可以是 <a href="constexpr.html#constexpr_.E5.87.BD.E6.95.B0" title="cpp/language/constexpr">constexpr 函数</a>的情况下隐式具有 constexpr。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S
<span class="br0">{</span>
    S<span class="br0">(</span><span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>             <span class="co1">// 错误：有默认实参</span>
    <span class="kw4">void</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> S<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span> <span class="co1">// 错误：返回类型不匹配</span>
    ~S<span class="br0">(</span><span class="br0">)</span> <span class="kw1">noexcept</span><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>     <span class="co1">// OK，异常说明可以不同</span>
<span class="kw1">private</span><span class="sy4">:</span>
    <span class="kw4">int</span> i<span class="sy4">;</span>
    S<span class="br0">(</span>S<span class="sy3">&amp;</span><span class="br0">)</span><span class="sy4">;</span>          <span class="co1">// OK，私有构造函数</span>
<span class="br0">}</span><span class="sy4">;</span>
 
S<span class="sy4">::</span><span class="me2">S</span><span class="br0">(</span>S<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span> <span class="co1">// OK，定义了构造函数</span></pre></div></div>
<p>显式预置的函数和隐式声明的函数统称为<i>预置</i> ﻿函数。它们的实际定义会隐式提供，详情见这些函数各自对应的页面。
</p>
<h4> <span class="mw-headline" id=".E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0">弃置函数</span></h4>
<p>如果函数定义具有语法 <span class="t-v">(<a href="function.html#.E7.89.88.E6.9C.AC_4">4</a>)</span><span class="t-rev-inl t-since-cxx26"><span> 或 <span class="t-v">(<a href="function.html#.E7.89.88.E6.9C.AC_5">5</a>)</span></span><span><span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span></span></span>，那么该函数被定义为<i>显式弃置的</i>。
</p><p>任何弃置函数的使用都是非良构的（程序无法编译）。这包含调用，包括显式（以函数调用运算符）及隐式（对弃置的重载运算符、特殊成员函数、分配函数等的调用），构成指向弃置函数的指针或成员指针，甚至是在不<a href="expressions.html#.E6.BD.9C.E5.9C.A8.E6.B1.82.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F" title="cpp/language/expressions">潜在求值</a>的表达式中使用弃置函数。
</p><p>非纯虚成员函数可以被定义为弃置，即便它被隐式 <a href="definition.html#ODR_.E4.BD.BF.E7.94.A8" title="cpp/language/definition">ODR 使用</a>。弃置函数只能被弃置函数覆写，而非弃置函数只能被非弃置函数覆写。
</p>
<table class="t-rev-begin">
<tr class="t-rev t-since-cxx26"><td>
<p>如果出现<span class="t-spar">字符串字面量</span>，那么鼓励实现将此文本作为其给出的诊断消息的一部分，用以展示弃置的理由或者给出替代建议。
</p>
</td>
<td><span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span></td></tr>
</table>
<p>如果函数被重载，那么首先进行<a href="overload_resolution.html" title="cpp/language/overload resolution">重载决议</a>，且只有在选择了弃置函数时程序才非良构：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> T
<span class="br0">{</span>
    <span class="kw4">void</span><span class="sy2">*</span> <a href="../memory/new/operator_new.html"><span class="kw690">operator new</span></a><span class="br0">(</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span>
    <span class="kw4">void</span><span class="sy2">*</span> <a href="../memory/new/operator_new.html"><span class="kw690">operator new</span></a><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="br0">)</span> <span class="sy1">=</span> delete<span class="br0">(</span><span class="st0">"new[] 已被弃置"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// C++26 起</span>
<span class="br0">}</span><span class="sy4">;</span>
 
T<span class="sy2">*</span> p <span class="sy1">=</span> new T<span class="sy4">;</span>    <span class="co1">// 错误：尝试调用弃置的 T::operator new</span>
T<span class="sy2">*</span> p <span class="sy1">=</span> new T<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// 错误：尝试调用弃置的 T::operator new[]，产生诊断消息“new[] 已被弃置”</span></pre></div></div>
<p>函数的弃置定义必须是翻译单元中的首条声明：已经声明过的函数不能声明为弃置的：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> T <span class="br0">{</span> T<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
T<span class="sy4">::</span><span class="me2">T</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span> <span class="co1">// 错误：必须在首条声明弃置</span></pre></div></div>
<h4> <span class="mw-headline" id=".E7.94.B1.E7.94.A8.E6.88.B7.E6.8F.90.E4.BE.9B.E7.9A.84.E5.87.BD.E6.95.B0">由用户提供的函数</span></h4>
<p>如果一个函数由用户声明且没有在它的首个声明被显式预置或显式弃置，那么它<i>由用户提供</i>。由用户提供的显式预置的函数（即在它的首个声明后被显式预置）在它被显式预置的地方定义；如果该函数被隐式定义为弃置的，那么程序非良构。需要为不断变化的代码库提供稳定的二进制接口的情况下，在函数的首个声明后再定义为预置可以保证执行效率，也能提供简明的定义。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// trivial 的所有特殊成员函数都分别在它们的首个声明处被显式预置，</span>
<span class="co1">// 因此它们都不由用户提供</span>
<span class="kw1">struct</span> trivial
<span class="br0">{</span>
    trivial<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    trivial<span class="br0">(</span><span class="kw4">const</span> trivial<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    trivial<span class="br0">(</span>trivial<span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    trivial<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> trivial<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    trivial<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>trivial<span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    ~trivial<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> nontrivial
<span class="br0">{</span>
    nontrivial<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 首个声明</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// 没有在首个声明处被显式预置，</span>
<span class="co1">// 因此该函数由用户提供并在此定义</span>
nontrivial<span class="sy4">::</span><span class="me2">nontrivial</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span></pre></div></div>
<h4> <span class="mw-headline" id=".E8.A7.A3.E5.86.B3.E6.AD.A7.E4.B9.89">解决歧义</span></h4>
<p>在以 <code><b>{</b></code><span class="t-rev-inl t-since-cxx26"><span> 或 <code><b>=</b></code></span><span><span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span></span></span> 开头的函数体和<a href="initialization.html" title="cpp/language/initialization">初始化器</a>间有歧义的情况下，检查<span class="t-spar">非指针声明符</span> ﻿的<a href="declarations.html#.E5.A3.B0.E6.98.8E.E7.AC.A6" title="cpp/language/declarations">声明符标识符</a>的类型来解决歧义：
</p>
<ul><li> 如果类型是函数类型，那么有歧义的记号序列会被视为函数体。
</li><li> 否则有歧义的记号序列会被视为初始化器。
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">using</span> T <span class="sy1">=</span> <span class="kw4">void</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 函数类型</span>
<span class="kw1">using</span> U <span class="sy1">=</span> <span class="kw4">int</span><span class="sy4">;</span>    <span class="co1">// 非函数类型</span>
 
T a<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// 定义一个什么也不做的函数</span>
U b<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// 值初始化一个 int 对象</span>
 
T c <span class="sy1">=</span> delete<span class="br0">(</span><span class="st0">"hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 定义一个被弃置的函数</span>
U d <span class="sy1">=</span> delete<span class="br0">(</span><span class="st0">"hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 以 delete 表达式的结果复制初始化一个 int 对象（非良构）</span></pre></div></div>
<p><span id="func"></span>
</p>
<h4> <span class="mw-headline" id="func">__func__</span></h4>
<p>在函数体内，如同以如下方式定义了函数局部的预定义变量 <span class="t-lc">__func__</span>：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> __func__<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="st0">"函数名"</span><span class="sy4">;</span></pre></div></div>
<p>此变量具有块作用域及静态存储期：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S
<span class="br0">{</span>
    S<span class="br0">(</span><span class="br0">)</span><span class="sy4">:</span> s<span class="br0">(</span>__func__<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// OK：初始化器列表是函数体的一部分</span>
    <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> s<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> s <span class="sy1">=</span> __func__<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：形参列表是声明符的一部分</span></pre></div></div>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw4">void</span> Foo<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> __func__ <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">struct</span> Bar
<span class="br0">{</span>
    Bar<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> __func__ <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span> <span class="br0">}</span>
    ~Bar<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> __func__ <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span> <span class="br0">}</span>
    <span class="kw1">struct</span> Pub <span class="br0">{</span> Pub<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> __func__ <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span> <span class="br0">}</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    Foo<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    Bar bar<span class="sy4">;</span>
    Bar<span class="sy4">::</span><span class="me2">Pub</span> pub<span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>可能的输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Foo Bar Pub ~Bar</pre></div></div> 
</div>
</td>
<td><span class="t-mark-rev t-since-cxx11" style="white-space: nowrap;">(C++11 起)</span></td></tr>
<tr class="t-rev t-since-cxx26"><td>
<h3> <span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.A5.91.E7.BA.A6.E8.AF.B4.E6.98.8E.E7.AC.A6">函数契约说明符</span></h3>
<p>函数声明和 <a href="lambda.html" title="cpp/language/lambda">lambda 表达式</a>可以包含<i>函数契约说明符 ﻿</i>的序列，说明符语法如下：
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>pre</b></code> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>(</b></code> <span class="t-spar">谓词</span> <code><b>)</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>post</b></code> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>(</b></code> <span class="t-spar">谓词</span> <code><b>)</b></code>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>post</b></code> <span class="t-spar">属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>(</b></code> <span class="t-spar">标识符</span> <span class="t-spar">结果属性</span> ﻿<span class="t-mark" style="white-space: nowrap;">(可选)</span> <code><b>:</b></code> <span class="t-spar">谓词</span> <code><b>)</b></code>
</td>
<td> (3)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<div class="t-li1"><span class="t-li">1)</span> 引入<i>前条件断言</i>。</div>
<div class="t-li1"><span class="t-li">2,3)</span> 引入<i>后条件断言</i>。</div>
<div class="t-li2"><span class="t-li">2)</span> 断言没有绑定到结果。</div>
<div class="t-li2"><span class="t-li">3)</span> 断言有绑定到结果。</div>
<table class="t-par-begin">


<tr class="t-par">
<td> <span class="t-spar">属性</span>
</td>
<td> -
</td>
<td> 附属于引入的契约断言的属性的列表
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">谓词</span>
</td>
<td> -
</td>
<td> （无括号的<a href="operator_other.html#.E5.86.85.E5.BB.BA.E7.9A.84.E9.80.97.E5.8F.B7.E8.BF.90.E7.AE.97.E7.AC.A6" title="cpp/language/operator other">逗号表达式</a>以外的）任意表达式
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">标识符</span>
</td>
<td> -
</td>
<td> 指代结果的标识符
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">结果属性</span>
</td>
<td> -
</td>
<td> 附属于结果绑定的属性的列表
</td></tr></table>
<p><br>
前条件断言和后条件断言统称为<i>函数契约断言</i>。
</p><p>函数契约断言是与函数关联的<a href="contracts.html" title="cpp/language/contracts">契约断言</a>。函数契约断言的谓词是它的<a href="implicit_conversion.html#.E6.8C.89.E8.AF.AD.E5.A2.83.E8.BD.AC.E6.8D.A2" title="cpp/language/implicit conversion">按语境转换</a>到 <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> 的<span class="t-spar">谓词</span>。
</p><p>以下函数不能声明有函数契约说明符：
</p>
<ul><li> <a href="virtual.html" title="cpp/language/virtual">虚函数</a>
</li><li> <a href="function.html#.E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0">弃置函数</a>
</li><li> 在首次声明中<a href="function.html#.E9.A2.84.E7.BD.AE.E5.87.BD.E6.95.B0">预置</a>的函数
</li></ul>
<h4> <span class="mw-headline" id=".E5.89.8D.E6.9D.A1.E4.BB.B6.E6.96.AD.E8.A8.80">前条件断言</span></h4>
<p>前条件断言与进入函数关联：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> divide<span class="br0">(</span><span class="kw4">int</span> dividend, <span class="kw4">int</span> divisor<span class="br0">)</span> pre<span class="br0">(</span>divisor <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> dividend <span class="sy2">/</span> divisor<span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">double</span> square_root<span class="br0">(</span><span class="kw4">double</span> num<span class="br0">)</span> pre<span class="br0">(</span>num <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <a href="../numeric/math/sqrt.html"><span class="kw1332">std::<span class="me2">sqrt</span></span></a><span class="br0">(</span>num<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<h4> <span class="mw-headline" id=".E5.90.8E.E6.9D.A1.E4.BB.B6.E6.96.AD.E8.A8.80">后条件断言</span></h4>
<p>后条件断言与正常退出函数关联。
</p><p>如果后条件断言有<span class="t-spar">标识符</span>，那么函数契约说明符会引入<span class="t-spar">标识符</span> ﻿作为关联函数的<i>结果绑定</i>。结果绑定表示对该函数的调用返回的对象或引用。结果绑定的类型是关联函数的返回类型。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> absolute_value<span class="br0">(</span><span class="kw4">int</span> num<span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> std<span class="sy4">::</span><span class="me2">abs</span><span class="br0">(</span>num<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">double</span> sine<span class="br0">(</span><span class="kw4">double</span> num<span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;=</span> <span class="sy2">-</span><span class="nu16">1.0</span> <span class="sy3">&amp;&amp;</span> r <span class="sy1">&lt;=</span> <span class="nu16">1.0</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span><a href="../numeric/math/isnan.html"><span class="kw1374">std::<span class="me2">isnan</span></span></a><span class="br0">(</span>num<span class="br0">)</span> <span class="sy3">||</span> <a href="../numeric/math/isinf.html"><span class="kw1373">std::<span class="me2">isinf</span></span></a><span class="br0">(</span>num<span class="br0">)</span><span class="br0">)</span>
        <span class="co1">// 以异常退出不会导致契约违背</span>
        <span class="kw1">throw</span> <a href="../error/invalid_argument.html"><span class="kw771">std::<span class="me2">invalid_argument</span></span></a><span class="br0">(</span><span class="st0">"参数非法"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">return</span> <a href="../numeric/math/sin.html"><span class="kw1336">std::<span class="me2">sin</span></span></a><span class="br0">(</span>num<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>如果后条件断言有<span class="t-spar">标识符</span>，而关联函数的返回类型是（可有 cv 限定的 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>），那么程序非良构：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：没有值能绑定到 “r”</span></pre></div></div>
<p>当非模板化函数声明的返回类型包含<a href="auto.html" title="cpp/language/auto">占位类型</a>时，有<span class="t-spar">标识符</span> ﻿的后条件断言只能在函数定义中出现：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> g<span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span><span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK，“g” 是模板</span>
 
<span class="kw4">auto</span> h<span class="br0">(</span><span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>      <span class="co1">// 错误：无法命名返回值</span>
 
<span class="kw4">auto</span> k<span class="br0">(</span><span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> r <span class="sy1">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span>       <span class="co1">// OK，“k” 是定义</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<h4> <span class="mw-headline" id=".E5.A5.91.E7.BA.A6.E4.B8.80.E8.87.B4.E6.80.A7">契约一致性</span></h4>
<p>函数或函数模板 <span class="t-c"><span class="mw-geshi cpp source-cpp">func</span></span> 的<a href="conflicting_declarations.html#.E7.9B.B8.E5.90.8C.E5.AE.9E.E4.BD.93.E7.9A.84.E5.A4.9A.E6.AC.A1.E5.A3.B0.E6.98.8E" title="cpp/language/conflicting declarations">重声明</a> <code>D</code> 要么不能有<span class="t-spar">契约说明</span> ﻿，要么<span class="t-spar">契约说明</span> ﻿必须和从 <code>D</code> 可及的首次声明 <code>F</code> 的<span class="t-spar">契约说明</span> ﻿相同。如果 <code>D</code> 和 <code>F</code> 在不同的翻译单元中，那么只要求在 <code>D</code> 附着于具名模块的情况下进行诊断。
</p><p>如果声明 <code>F1</code> 是 <span class="t-c"><span class="mw-geshi cpp source-cpp">func</span></span> 在某个翻译单元中的首次声明，而声明 <code>F2</code> 是 <span class="t-c"><span class="mw-geshi cpp source-cpp">func</span></span> 在另一个翻译单元中的首次声明，那么 <code>F1</code> 和 <code>F2</code> 必须指定相同的<span class="t-spar">契约说明</span>，不要求诊断。
</p><p>两个<span class="t-spar">契约说明</span> ﻿在以相同顺序包含相同的函数契约说明符时相同。
</p><p>如果满足以下所有条件，那么函数声明 <code>D1</code> 上的函数契约说明符 <code>C1</code> 与函数声明 <code>D2</code> 上的函数契约说明符 <code>C2</code> 相同：
</p>
<ul><li> <code>C1</code> 和 <code>C2</code> 各自的<span class="t-spar">谓词</span> ﻿分别被放在声明 <code>D1</code> 和 <code>D2</code> 的函数定义中时（如果 <code>D1</code> 和 <code>D2</code> 在不同的翻译单元中，那么在每个<span class="t-spar">谓词</span> ﻿中定义的对应实体表现如同只存在具有一个定义的单个实体），它们在除了以下重命名外满足<a href="definition.html#ODR" title="cpp/language/definition">单一定义规则</a>：
<ul><li> 对声明的函数的形参的重命名。
</li><li> 对声明的函数的外围模板的模板形参的重命名。
</li><li> 对结果绑定（如果存在）的重命名。
</li></ul>
</li><li> <code>C1</code> 和 <code>C2</code> 要么都有<span class="t-spar">标识符</span>，要么都没有。
</li></ul>
<p>如果只是因为比较<span class="t-spar">谓词</span> ﻿中的两个 lambda 表达式而不满足以上条件，那么不要求诊断。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">bool</span> b1, b2<span class="sy4">;</span>
 
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> pre <span class="br0">(</span>b1<span class="br0">)</span> pre<span class="br0">(</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span> <span class="kw1">return</span> b2<span class="sy4">;</span> <span class="br0">}</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK，省略函数契约说明符</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> pre <span class="br0">(</span>b1<span class="br0">)</span> pre<span class="br0">(</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span> <span class="kw1">return</span> b2<span class="sy4">;</span> <span class="br0">}</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：闭包类型不同</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> pre <span class="br0">(</span>b1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：函数契约说明符不同</span>
 
<span class="kw4">int</span> g<span class="br0">(</span><span class="br0">)</span> post<span class="br0">(</span>r <span class="sy4">:</span> b1<span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">int</span> g<span class="br0">(</span><span class="br0">)</span> post<span class="br0">(</span>b1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：没有结果绑定</span>
 
<span class="kw1">namespace</span> N
<span class="br0">{</span>
    <span class="kw4">void</span> h<span class="br0">(</span><span class="br0">)</span> pre <span class="br0">(</span>b1<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">bool</span> b1<span class="sy4">;</span>
    <span class="kw4">void</span> h<span class="br0">(</span><span class="br0">)</span> pre <span class="br0">(</span>b1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 错误：函数契约说明符因单一定义规则而不同</span>
<span class="br0">}</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx26" style="white-space: nowrap;">(C++26 起)</span></td></tr>
</table>
<h3><span class="mw-headline" id=".E6.B3.A8.E8.A7.A3">注解</span></h3>
<p>在使用直接初始化语法的变量声明和函数声明之间有歧义的情况下，编译器选择函数声明；见<a href="direct_initialization.html#.E6.B3.A8.E8.A7.A3" title="cpp/language/direct initialization">直接初始化</a>页面。
</p>
<table class="wikitable">

<tr>
<th>功能特性测试宏
</th>
<th><abbr title="采纳该特性的年/月。每个值下面的链接指向编译期支持页面中给定功能特性的条目。">值</abbr>
</th>
<th><abbr title="引入该特性的标准；DR 意为针对该修订版的缺陷报告">标准</abbr>
</th>
<th>功能特性
</th></tr>
<tr>
<td><a href="../feature_test.html#cpp_decltype_auto" title="cpp/feature test"><code>__cpp_decltype_auto</code></a></td>
<td><a href="../compiler_support/14.html#cpp_decltype_auto_201304L" title="cpp/compiler support/14"><code>201304L</code></a></td>
<td><span class="t-mark" style="white-space: nowrap;">(C++14)</span></td>
<td><a href="auto.html" title="cpp/language/auto"><code>decltype(auto)</code></a>
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_return_type_deduction" title="cpp/feature test"><code>__cpp_return_type_deduction</code></a></td>
<td><a href="../compiler_support/14.html#cpp_return_type_deduction_201304L" title="cpp/compiler support/14"><code>201304L</code></a></td>
<td><span class="t-mark" style="white-space: nowrap;">(C++14)</span></td>
<td>普通函数的<a href="function.html#.E8.BF.94.E5.9B.9E.E7.B1.BB.E5.9E.8B.E6.8E.A8.E5.AF.BC">返回类型推导</a>
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_explicit_this_parameter" title="cpp/feature test"><code>__cpp_explicit_this_parameter</code></a></td>
<td><a href="../compiler_support/23.html#cpp_explicit_this_parameter_202110L" title="cpp/compiler support/23"><code>202110L</code></a></td>
<td><span class="t-mark" style="white-space: nowrap;">(C++23)</span></td>
<td><a href="function.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E5.BD.A2.E5.8F.82">显式对象形参</a>（<a href="member_functions.html#.E6.98.BE.E5.BC.8F.E5.AF.B9.E8.B1.A1.E6.88.90.E5.91.98.E5.87.BD.E6.95.B0" title="cpp/language/member functions">推导 <span class="mw-geshi cpp source-cpp">this</span></a>）
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_deleted_function" title="cpp/feature test"><code>__cpp_deleted_function</code></a></td>
<td><a href="../compiler_support/26.html#cpp_deleted_function_202403L" title="cpp/compiler support/26"><code>202403L</code></a></td>
<td><span class="t-mark" style="white-space: nowrap;">(C++26)</span></td>
<td>带有理由的弃置函数
</td></tr></table>
<h3><span class="mw-headline" id=".E5.85.B3.E9.94.AE.E8.AF.8D">关键词</span></h3>
<p><a href="../keyword/default.html" title="cpp/keyword/default"><tt>default</tt></a>,
<a href="../keyword/delete.html" title="cpp/keyword/delete"><tt>delete</tt></a>
</p>
<h3><span class="mw-headline" id=".E7.A4.BA.E4.BE.8B">示例</span></h3>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<span class="co1">// 拥有默认实参的简单函数，不返回内容</span>
<span class="kw4">void</span> f0<span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1233">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> arg <span class="sy1">=</span> <span class="st0">"world!"</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Hello, "</span> <span class="sy1">&lt;&lt;</span> arg <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 命名空间（文件）作用域中的声明</span>
<span class="co1">// （定义在后面提供）</span>
<span class="kw4">int</span> f1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="co1">// 返回指向 f0 的指针的函数，C++11 前的风格</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>fp03<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1233">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> f0<span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 返回指向 f0 的指针的函数</span>
<span class="kw4">auto</span> fp11<span class="br0">(</span><span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">void</span><span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1233">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> f0<span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    f0<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    fp03<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="st0">"test!"</span><span class="br0">)</span><span class="sy4">;</span>
    fp11<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="st0">"again!"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">int</span> f2<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1233">std::<span class="me2">string</span></span></a><span class="br0">)</span> <span class="kw1">noexcept</span><span class="sy4">;</span> <span class="co1">// 函数作用域中的声明</span>
    <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"f2(<span class="es1">\"</span>bad<span class="es1">\"</span>)："</span> <span class="sy1">&lt;&lt;</span> f2<span class="br0">(</span><span class="st0">"bad"</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"f2(<span class="es1">\"</span>42<span class="es1">\"</span>)："</span> <span class="sy1">&lt;&lt;</span> f2<span class="br0">(</span><span class="st0">"42"</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 简单的非成员函数，返回 int</span>
<span class="kw4">int</span> f1<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="nu8">007</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 拥有异常说明和函数 try 块的函数</span>
<span class="kw4">int</span> f2<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1233">std::<span class="me2">string</span></span></a> str<span class="br0">)</span> <span class="kw1">noexcept</span>
<span class="kw1">try</span>
<span class="br0">{</span> 
    <span class="kw1">return</span> <a href="../string/basic_string/stol.html"><span class="kw1260">std::<span class="me2">stoi</span></span></a><span class="br0">(</span>str<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw1">catch</span> <span class="br0">(</span><span class="kw4">const</span> <a href="../error/exception.html"><span class="kw766">std::<span class="me2">exception</span></span></a><span class="sy3">&amp;</span> e<span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cerr.html"><span class="kw1764">std::<span class="me2">cerr</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"stoi() 失败！<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// 弃置函数，尝试调用它会造成编译错误</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> delete
<span class="co2">#   if __cpp_deleted_function</span>
    <span class="br0">(</span><span class="st0">"理由"</span><span class="br0">)</span>
<span class="co2">#   endif</span>
<span class="sy4">;</span></pre></div></div>
<p>可能的输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">stoi() 失败！
Hello, world!
Hello, test!
Hello, again!
f2("bad")：0
f2("42")：42</pre></div></div> 
</div>
<h3><span class="mw-headline" id=".E7.BC.BA.E9.99.B7.E6.8A.A5.E5.91.8A">缺陷报告</span></h3>
<p>下列更改行为的缺陷报告追溯地应用于以前出版的 C++ 标准。
</p>
<table class="dsctable" style="font-size:0.8em">
<tr>
<th> 缺陷报告
</th>
<th> 应用于
</th>
<th> 出版时的行为
</th>
<th> 正确行为
</th></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/135.html">CWG 135</a>
</td>
<td> C++98
</td>
<td> 类内的成员函数定义的形参和返回值不能是类本身，因为它还不完整
</td>
<td> 允许此类定义
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/332.html">CWG 332</a>
</td>
<td> C++98
</td>
<td> 函数形参可以是有 cv 限定的 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 类型
</td>
<td> 已禁止
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/393.html">CWG 393</a>
</td>
<td> C++98
</td>
<td> 含有到未知边界数组的指针/引用的类型不能作为形参
</td>
<td> 允许这些类型
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/452.html">CWG 452</a>
</td>
<td> C++98
</td>
<td> 成员初始化器列表不是函数体的一部分
</td>
<td> 是函数体的一部分
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/577.html">CWG 577</a>
</td>
<td> C++98
</td>
<td> 待决 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 类型可以用来声明无形参函数
</td>
<td> 只有非待决的 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 可以
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1327.html">CWG 1327</a>
</td>
<td> C++11
</td>
<td> 显式预置或弃置的函数定义不能带有 <span class="mw-geshi cpp source-cpp">override</span> 或 <span class="mw-geshi cpp source-cpp">final</span> 说明符
</td>
<td> 可以带有这些说明符
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1355.html">CWG 1355</a>
</td>
<td> C++11
</td>
<td> 只有特殊成员函数能由用户提供
</td>
<td> 拓展到所有函数
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1394.html">CWG 1394</a>
</td>
<td> C++11
</td>
<td> 弃置函数不能有不完整类型的形参或返回不完整类型
</td>
<td> 允许这些地方有不完整的返回类型
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html">CWG 1824</a>
</td>
<td> C++98
</td>
<td> 函数定义的返回类型和形参类型的完整性检查也会在函数定义的语境外进行
</td>
<td> 只能在函数定义的语境中检查
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1877.html">CWG 1877</a>
</td>
<td> C++14
</td>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">return</span><span class="sy4">;</span></span></span> 在返回类型推导中被视为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">return</span> <span class="kw4">void</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</td>
<td> 此时直接将返回类型推导成 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2015.html">CWG 2015</a>
</td>
<td> C++11
</td>
<td> 虚弃置函数的隐式 ODR 使用非良构
</td>
<td> 将此类 ODR 使用从使用禁止豁免
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2044.html">CWG 2044</a>
</td>
<td> C++14
</td>
<td> 返回 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 但声明的返回类型是<br><span class="mw-geshi cpp source-cpp">decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span></span> 的函数的返回类型推导会失败
</td>
<td> 更新推导规则以处理这种情况
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2081.html">CWG 2081</a>
</td>
<td> C++14
</td>
<td> 即使函数的最初声明没有使用返回类型推导，它的重声明也可以使用
</td>
<td> 不能使用
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2144.html">CWG 2144</a>
</td>
<td> C++11
</td>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span><span class="br0">}</span></span></span> 在同一个地方既可以是函数体也可以是初始化器
</td>
<td> 通过声明符标识符的类型来区分
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2145.html">CWG 2145</a>
</td>
<td> C++98
</td>
<td> 函数定义中<span class="t-spar">声明符</span> ﻿不能被圆括号包围
</td>
<td> 可以包围
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2259.html">CWG 2259</a>
</td>
<td> C++11
</td>
<td> 圆括号包围类型名称时产生的歧义的解决规则未覆盖 lambda 表达式
</td>
<td> 已覆盖
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2430.html">CWG 2430</a>
</td>
<td> C++98
</td>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html">CWG 问题 1824</a> 的解决方案导致在类定义中的<br>函数定义中不能将该类作为返回类型形参类型
</td>
<td> 只能在函数体中检查
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2760.html">CWG 2760</a>
</td>
<td> C++98
</td>
<td> 构造函数的函数体不包括未在常规函数体中指定的初始化
</td>
<td> 也包括这些初始化
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2831.html">CWG 2831</a>
</td>
<td> C++20
</td>
<td> 带有 <span class="t-spar">requires子句</span> ﻿的函数定义可以定义非模板化函数
</td>
<td> 已禁止
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2846.html">CWG 2846</a>
</td>
<td> C++23
</td>
<td> 显式对象成员函数不能有类外定义
</td>
<td> 可以有
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2915.html">CWG 2915</a>
</td>
<td> C++23
</td>
<td> 无名显式对象形参可以具有 <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> 类型
</td>
<td> 已禁止
</td></tr></table>
<h3><span class="mw-headline" id=".E5.8F.82.E9.98.85">参阅</span></h3>
<table class="t-dsc-begin">

<tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span class=""><span>声明函数</span></span>的 <span><span><a href="../../c/language/function_declaration.html" title="c/language/function declaration">C 文档</a></span></span></div>
</td></tr>

</table>

<!-- 
NewPP limit report
Preprocessor visited node count: 12963/1000000
Preprocessor generated node count: 23495/1000000
Post‐expand include size: 257422/4194304 bytes
Template argument size: 85002/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:2717-0!*!0!!zh!*!zh!* and timestamp 20250323172301 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/language/function&amp;oldid=99466">https://zh.cppreference.com/mwiki/index.php?title=cpp/language/function&amp;oldid=99466</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/cpp/language/function">Online version</a></li><li>Offline version retrieved 2025-04-04 09:58.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2025年2月27日 (星期四) 08:48。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<!-- Served in 0.037 secs. -->
	</body>
<!-- Cached 20250323193346 -->
</html>